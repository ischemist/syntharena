// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

datasource db {
  provider = "sqlite"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid(2))
  username  String   @unique
  createdAt DateTime @default(now())
}

// =================================================================================
// 1. CHEMISTRY & TOPOLOGY (The "Graph" Layer)
// Matches retrocast.models.chem
// =================================================================================

model Molecule {
  id       String @id @default(cuid(2))
  inchikey String @unique // The true canonical identifier
  smiles   String // Canonical SMILES

  // Relations
  stockItems       StockItem[]
  routeNodes       RouteNode[]
  benchmarkTargets BenchmarkTarget[]

  @@index([smiles])
}

// =================================================================================
// 2. BENCHMARKS (The "Exam" Layer)
// Matches retrocast.models.benchmark
// =================================================================================

model BenchmarkSet {
  id             String  @id @default(cuid())
  name           String  @unique // e.g. "mkt-lin-500"
  description    String?
  stockName      String? // The "stock_name" required by the benchmark contract
  hasGroundTruth Boolean @default(false) // All-or-nothing: targets either all have GT routes or none do

  createdAt DateTime @default(now())

  targets    BenchmarkTarget[]
  runs       PredictionRun[]
  statistics ModelRunStatistics[]
}

model BenchmarkTarget {
  id             String @id @default(cuid())
  benchmarkSetId String
  targetId       String // The external ID, e.g. "n5-00123"
  moleculeId     String // The SMILES/InchiKey link

  // Metadata for stratification (cached from Python model)
  routeLength  Int? // Length of GT route
  isConvergent Boolean? // Is GT route convergent?
  metadata     String? // JSON blob for other metadata

  // Ground Truth Link
  // A target might have a ground truth route. This route is stored in the Route table
  // but usually has no ModelInstance associated with it.
  groundTruthRouteId String? @unique

  // Relations
  benchmarkSet     BenchmarkSet      @relation(fields: [benchmarkSetId], references: [id])
  molecule         Molecule          @relation(fields: [moleculeId], references: [id])
  groundTruthRoute Route?            @relation("GroundTruth", fields: [groundTruthRouteId], references: [id])
  predictionRoutes PredictionRoute[]

  @@unique([benchmarkSetId, targetId])
}

// =================================================================================
// 3. MODELS & EXECUTION (The "Prediction" Layer)
// Matches data/3-processed/
// =================================================================================

model Algorithm {
  id    String  @id @default(cuid())
  name  String  @unique // "DirectMultiStep"
  paper String?

  instances ModelInstance[]
}

model ModelInstance {
  id          String  @id @default(cuid())
  algorithmId String
  name        String  @unique // "dms-explorer-xl"
  version     String?
  metadata    String? // JSON: training set info, hyperparams

  algorithm Algorithm       @relation(fields: [algorithmId], references: [id])
  runs      PredictionRun[]
}

// Represents one "folder" in your data/3-processed structure
// e.g., data/3-processed/mkt-lin-500/dms-explorer-xl
model PredictionRun {
  id              String @id @default(cuid())
  modelInstanceId String
  benchmarkSetId  String

  // Provenance from Manifest
  retrocastVersion String?
  commandParams    String? // JSON of args
  executedAt       DateTime @default(now())

  // Stats from RunStatistics
  totalTimeMs    Float? // Wall time
  totalRoutes    Int // final_unique_routes_saved (now counts PredictionRoutes)
  avgRouteLength Float? // Average route length across all routes

  modelInstance    ModelInstance        @relation(fields: [modelInstanceId], references: [id])
  benchmarkSet     BenchmarkSet         @relation(fields: [benchmarkSetId], references: [id])
  predictionRoutes PredictionRoute[]
  statistics       ModelRunStatistics[]

  @@unique([modelInstanceId, benchmarkSetId]) // Assuming one run per version per set
}

model Route {
  id String @id @default(cuid())

  // Core Route Properties (Topology-level, unique)
  signature   String @unique // SHA256 from get_signature() (topology only) - NOW REQUIRED & UNIQUE
  contentHash String @unique // SHA256 from get_content_hash() - NOW UNIQUE

  // Cached Computations (for fast filtering)
  length       Int
  isConvergent Boolean

  // Relations
  // This reverse relation allows us to access the GT route from the target
  asGroundTruthFor BenchmarkTarget? @relation("GroundTruth")

  nodes       RouteNode[]
  predictions PredictionRoute[] // NEW: One route can be predicted multiple times
}

// Junction table: Connects a Route to a (PredictionRun, Target, Rank)
// This represents one "prediction" of a route by a model
model PredictionRoute {
  id              String @id @default(cuid())
  routeId         String // The unique route structure
  predictionRunId String // The model run that predicted this
  targetId        String // The target this prediction is for
  rank            Int // 1-indexed rank within this target/run

  metadata String? // JSON: scores, confidence, etc. (prediction-specific)

  // Relations
  route             Route              @relation(fields: [routeId], references: [id], onDelete: Cascade)
  predictionRun     PredictionRun      @relation(fields: [predictionRunId], references: [id], onDelete: Cascade)
  target            BenchmarkTarget    @relation(fields: [targetId], references: [id], onDelete: Cascade)
  solvabilityStatus RouteSolvability[]

  // Constraints
  @@unique([predictionRunId, targetId, rank]) // Each rank is unique per target/run
  @@unique([routeId, predictionRunId, targetId]) // Prevents duplicate route structures per target/run (intentional)
  @@index([targetId, rank])
  @@index([predictionRunId])
  @@index([routeId])
}

model RouteNode {
  id         String  @id @default(cuid())
  routeId    String
  moleculeId String
  parentId   String? // Tree structure

  // Reaction Step Data (The "Edge" info)
  // If this node is a product, how was it made?
  isLeaf       Boolean @default(false)
  reactionHash String? // For checking reaction overlap
  template     String?
  metadata     String? // JSON: reagents, solvents, mapper output

  // Relations
  route    Route       @relation(fields: [routeId], references: [id], onDelete: Cascade)
  molecule Molecule    @relation(fields: [moleculeId], references: [id])
  parent   RouteNode?  @relation("ReactionTree", fields: [parentId], references: [id], onDelete: SetNull, onUpdate: NoAction)
  children RouteNode[] @relation("ReactionTree")

  @@index([routeId])
}

// =================================================================================
// 4. STATISTICS & METRICS (Pre-computed results from Python pipeline)
// Matches data/5-results/ and Python ModelStatistics Pydantic model
// =================================================================================

enum ReliabilityCode {
  OK // Reliable estimate
  LOW_N // Sample size too small (n < threshold)
  EXTREME_P // Probability near boundary (p very close to 0 or 1)
}

model ModelRunStatistics {
  id              String   @id @default(cuid())
  predictionRunId String
  benchmarkSetId  String
  stockId         String
  statisticsJson  String // Full ModelStatistics JSON blob for flexibility
  computedAt      DateTime @default(now())

  // Relations
  predictionRun PredictionRun           @relation(fields: [predictionRunId], references: [id])
  benchmarkSet  BenchmarkSet            @relation(fields: [benchmarkSetId], references: [id])
  stock         Stock                   @relation(fields: [stockId], references: [id])
  metrics       StratifiedMetricGroup[]

  @@unique([predictionRunId, stockId]) // Multiple stocks per run
  @@index([predictionRunId])
  @@index([stockId])
}

model StratifiedMetricGroup {
  id           String @id @default(cuid())
  statisticsId String

  // Metric identification
  metricName String // "Solvability", "Top-1", "Top-5", "Top-10", etc.
  groupKey   Int? // NULL for overall, route_length (2,3,4,5,6...) for stratified

  // Metric values (stored as 0-1, convert to percentage in UI)
  value    Float
  ciLower  Float
  ciUpper  Float
  nSamples Int

  // Reliability assessment
  reliabilityCode    ReliabilityCode
  reliabilityMessage String

  // Relations
  statistics ModelRunStatistics @relation(fields: [statisticsId], references: [id], onDelete: Cascade)

  @@index([statisticsId, metricName]) // Fast filtering by metric
  @@index([metricName, groupKey]) // Fast stratified queries
}

// =================================================================================
// 5. SCORING & EVALUATION (The "Stock" Layer)
// Matches retrocast.models.evaluation and data/4-scored/
// =================================================================================

model Stock {
  id          String  @id @default(cuid(2))
  name        String  @unique // "buyables-stock" (matches directory name)
  description String?

  items       StockItem[]
  evaluations RouteSolvability[]
  statistics  ModelRunStatistics[]
}

model StockItem {
  id         String @id @default(cuid(2))
  stockId    String
  moleculeId String

  stock    Stock    @relation(fields: [stockId], references: [id])
  molecule Molecule @relation(fields: [moleculeId], references: [id])

  @@unique([stockId, moleculeId])
}

// The result of `TargetEvaluation`
// effectively "ScoredRoute" but normalized
// NOTE: Solvability is per-PREDICTION, not per-route (same route can have different solvability in different contexts)
model RouteSolvability {
  id                String @id @default(cuid())
  predictionRouteId String // Changed from routeId - solvability is per prediction
  stockId           String

  isSolvable Boolean
  isGtMatch  Boolean // "Does this route match the ground truth?"

  // You might want to store specific metric data here if needed
  // e.g. "number of unavailable leaves"

  predictionRoute PredictionRoute @relation(fields: [predictionRouteId], references: [id], onDelete: Cascade)
  stock           Stock           @relation(fields: [stockId], references: [id])

  @@unique([predictionRouteId, stockId])
}
