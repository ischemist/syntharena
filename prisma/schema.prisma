// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

datasource db {
  provider = "sqlite"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid(2))
  username  String   @unique
  createdAt DateTime @default(now())
}

// =================================================================================
// 1. CHEMISTRY & TOPOLOGY (The "Graph" Layer)
// Matches retrocast.models.chem
// =================================================================================

model Molecule {
  id       String @id @default(cuid(2))
  inchikey String @unique // The true canonical identifier
  smiles   String // Canonical SMILES

  // Relations
  stockItems       StockItem[]
  routeNodes       RouteNode[]
  benchmarkTargets BenchmarkTarget[]

  @@index([smiles])
}

// =================================================================================
// 2. BENCHMARKS (The "Exam" Layer)
// Matches retrocast.models.benchmark
// =================================================================================

model BenchmarkSet {
  id                  String  @id @default(cuid())
  name                String  @unique // e.g. "mkt-lin-500"
  description         String?
  stockId             String // Direct reference to the stock
  hasAcceptableRoutes Boolean @default(false) // All-or-nothing: targets either all have acceptable routes or none do

  createdAt DateTime @default(now())

  stock      Stock                @relation(fields: [stockId], references: [id])
  targets    BenchmarkTarget[]
  runs       PredictionRun[]
  statistics ModelRunStatistics[]
}

model BenchmarkTarget {
  id             String @id @default(cuid())
  benchmarkSetId String
  targetId       String // The external ID, e.g. "n5-00123"
  moleculeId     String // The SMILES/InchiKey link

  // Metadata for stratification (cached from Python model)
  // These are computed from the PRIMARY acceptable route (index 0) if available
  routeLength  Int? // Length of primary acceptable route
  isConvergent Boolean? // Is primary acceptable route convergent?
  metadata     String? // JSON blob for other metadata

  // Relations
  benchmarkSet     BenchmarkSet      @relation(fields: [benchmarkSetId], references: [id])
  molecule         Molecule          @relation(fields: [moleculeId], references: [id])
  acceptableRoutes AcceptableRoute[]
  predictionRoutes PredictionRoute[]

  @@unique([benchmarkSetId, targetId])
}

// Junction table: Links BenchmarkTarget to multiple Route records (acceptable routes)
// Preserves array order from Python model via routeIndex (0 = primary route)
model AcceptableRoute {
  id                String @id @default(cuid())
  benchmarkTargetId String
  routeId           String
  routeIndex        Int // 0-based index in acceptable_routes array (0 = primary)

  target BenchmarkTarget @relation(fields: [benchmarkTargetId], references: [id], onDelete: Cascade)
  route  Route           @relation(fields: [routeId], references: [id], onDelete: Cascade)

  @@unique([benchmarkTargetId, routeId]) // One link per target-route pair
  @@unique([benchmarkTargetId, routeIndex]) // Index is unique per target
  @@index([benchmarkTargetId])
  @@index([routeId])
}

// =================================================================================
// 3. MODELS & EXECUTION (The "Prediction" Layer)
// Matches data/3-processed/
// =================================================================================

model Algorithm {
  id    String  @id @default(cuid())
  name  String  @unique // "DirectMultiStep"
  paper String?

  instances ModelInstance[]
}

model ModelInstance {
  id          String  @id @default(cuid())
  algorithmId String
  name        String  @unique // "dms-explorer-xl"
  version     String?
  metadata    String? // JSON: training set info, hyperparams

  algorithm Algorithm       @relation(fields: [algorithmId], references: [id])
  runs      PredictionRun[]
}

// Represents one "folder" in your data/3-processed structure
// e.g., data/3-processed/mkt-lin-500/dms-explorer-xl
model PredictionRun {
  id              String @id @default(cuid())
  modelInstanceId String
  benchmarkSetId  String

  // Provenance from Manifest
  retrocastVersion String?
  commandParams    String? // JSON of args
  executedAt       DateTime @default(now())

  // Stats from RunStatistics
  totalTimeMs    Float? // Wall time
  totalRoutes    Int // final_unique_routes_saved (now counts PredictionRoutes)
  avgRouteLength Float? // Average route length across all routes

  modelInstance    ModelInstance        @relation(fields: [modelInstanceId], references: [id])
  benchmarkSet     BenchmarkSet         @relation(fields: [benchmarkSetId], references: [id])
  predictionRoutes PredictionRoute[]
  statistics       ModelRunStatistics[]

  @@unique([modelInstanceId, benchmarkSetId]) // Assuming one run per version per set
}

model Route {
  id String @id @default(cuid())

  // Core Route Properties (Topology-level, unique)
  signature   String @unique // SHA256 from get_signature() (topology only) - NOW REQUIRED & UNIQUE
  contentHash String @unique // SHA256 from get_content_hash() - NOW UNIQUE

  // Cached Computations (for fast filtering)
  length       Int
  isConvergent Boolean

  // Relations
  asAcceptableRouteFor AcceptableRoute[]
  nodes                RouteNode[]
  predictions          PredictionRoute[] // One route can be predicted multiple times
}

// Junction table: Connects a Route to a (PredictionRun, Target, Rank)
// This represents one "prediction" of a route by a model
model PredictionRoute {
  id              String @id @default(cuid())
  routeId         String // The unique route structure
  predictionRunId String // The model run that predicted this
  targetId        String // The target this prediction is for
  rank            Int // 1-indexed rank within this target/run

  metadata String? // JSON: scores, confidence, etc. (prediction-specific)

  // Relations
  route             Route              @relation(fields: [routeId], references: [id], onDelete: Cascade)
  predictionRun     PredictionRun      @relation(fields: [predictionRunId], references: [id], onDelete: Cascade)
  target            BenchmarkTarget    @relation(fields: [targetId], references: [id], onDelete: Cascade)
  solvabilityStatus RouteSolvability[]

  // Constraints
  @@unique([predictionRunId, targetId, rank]) // Each rank is unique per target/run
  @@unique([routeId, predictionRunId, targetId]) // Prevents duplicate route structures per target/run (intentional)
  @@index([targetId, rank])
  @@index([predictionRunId])
  @@index([routeId])
}

model RouteNode {
  id         String  @id @default(cuid())
  routeId    String
  moleculeId String
  parentId   String? // Tree structure

  // Reaction Step Data (The "Edge" info)
  // If this node is a product, how was it made?
  isLeaf       Boolean @default(false)
  reactionHash String? // For checking reaction overlap
  template     String?
  metadata     String? // JSON: reagents, solvents, mapper output

  // Relations
  route    Route       @relation(fields: [routeId], references: [id], onDelete: Cascade)
  molecule Molecule    @relation(fields: [moleculeId], references: [id])
  parent   RouteNode?  @relation("ReactionTree", fields: [parentId], references: [id], onDelete: SetNull, onUpdate: NoAction)
  children RouteNode[] @relation("ReactionTree")

  @@index([routeId])
}

// =================================================================================
// 4. STATISTICS & METRICS (Pre-computed results from Python pipeline)
// Matches data/5-results/ and Python ModelStatistics Pydantic model
// =================================================================================

enum ReliabilityCode {
  OK // Reliable estimate
  LOW_N // Sample size too small (n < threshold)
  EXTREME_P // Probability near boundary (p very close to 0 or 1)
}

model ModelRunStatistics {
  id              String   @id @default(cuid())
  predictionRunId String
  benchmarkSetId  String
  stockId         String
  statisticsJson  String // Full ModelStatistics JSON blob for flexibility
  computedAt      DateTime @default(now())

  // Relations
  predictionRun PredictionRun           @relation(fields: [predictionRunId], references: [id])
  benchmarkSet  BenchmarkSet            @relation(fields: [benchmarkSetId], references: [id])
  stock         Stock                   @relation(fields: [stockId], references: [id])
  metrics       StratifiedMetricGroup[]

  @@unique([predictionRunId, stockId]) // Multiple stocks per run
  @@index([predictionRunId])
  @@index([stockId])
}

model StratifiedMetricGroup {
  id           String @id @default(cuid())
  statisticsId String

  // Metric identification
  metricName String // "Solvability", "Top-1", "Top-5", "Top-10", etc.
  groupKey   Int? // NULL for overall, route_length (2,3,4,5,6...) for stratified

  // Metric values (stored as 0-1, convert to percentage in UI)
  value    Float
  ciLower  Float
  ciUpper  Float
  nSamples Int

  // Reliability assessment
  reliabilityCode    ReliabilityCode
  reliabilityMessage String

  // Relations
  statistics ModelRunStatistics @relation(fields: [statisticsId], references: [id], onDelete: Cascade)

  @@index([statisticsId, metricName]) // Fast filtering by metric
  @@index([metricName, groupKey]) // Fast stratified queries
}

// =================================================================================
// 5. SCORING & EVALUATION (The "Stock" Layer)
// Matches retrocast.models.evaluation and data/4-scored/
// =================================================================================

model Stock {
  id          String  @id @default(cuid(2))
  name        String  @unique // "buyables-stock" (matches directory name)
  description String?

  benchmarks  BenchmarkSet[]
  items       StockItem[]
  evaluations RouteSolvability[]
  statistics  ModelRunStatistics[]
}

model StockItem {
  id         String @id @default(cuid(2))
  stockId    String
  moleculeId String

  stock    Stock    @relation(fields: [stockId], references: [id])
  molecule Molecule @relation(fields: [moleculeId], references: [id])

  @@unique([stockId, moleculeId])
}

// The result of `TargetEvaluation`
// effectively "ScoredRoute" but normalized
// NOTE: Solvability is per-PREDICTION, not per-route (same route can have different solvability in different contexts)
model RouteSolvability {
  id                String @id @default(cuid())
  predictionRouteId String // Changed from routeId - solvability is per prediction
  stockId           String

  isSolvable            Boolean
  matchesAcceptable     Boolean // "Does this route match ANY acceptable route?"
  matchedAcceptableIndex Int?    // Which acceptable route was matched (0-based index, null if no match)

  // You might want to store specific metric data here if needed
  // e.g. "number of unavailable leaves"

  predictionRoute PredictionRoute @relation(fields: [predictionRouteId], references: [id], onDelete: Cascade)
  stock           Stock           @relation(fields: [stockId], references: [id])

  @@unique([predictionRouteId, stockId])
}
