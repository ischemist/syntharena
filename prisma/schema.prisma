// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

datasource db {
  provider = "sqlite"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid(2))
  username  String   @unique
  createdAt DateTime @default(now())
}

// =================================================================================
// 1. CHEMISTRY & TOPOLOGY (The "Graph" Layer)
// Matches retrocast.models.chem
// =================================================================================

model Molecule {
  id       String @id @default(cuid(2))
  inchikey String @unique // The true canonical identifier
  smiles   String // Canonical SMILES

  // Relations
  stockItems       StockItem[]
  routeNodes       RouteNode[]
  benchmarkTargets BenchmarkTarget[]

  @@index([smiles])
  @@index([inchikey, smiles])
}

// =================================================================================
// 2. BENCHMARKS (The "Exam" Layer)
// Matches retrocast.models.benchmark
// =================================================================================

enum BenchmarkSeries {
  MARKET // mkt-* for chemists
  REFERENCE // ref-* for developers
  LEGACY // random-* for Reviewer #3
  OTHER // future-proofing
}

model BenchmarkSet {
  id                  String  @id @default(cuid())
  name                String  @unique // e.g. "mkt-lin-500"
  description         String?
  stockId             String // Direct reference to the stock
  hasAcceptableRoutes Boolean @default(false) // All-or-nothing: targets either all have acceptable routes or none do

  createdAt DateTime @default(now())

  series   BenchmarkSeries @default(OTHER)
  isListed Boolean         @default(true) // for de-prioritizing -single-gt

  stock      Stock                @relation(fields: [stockId], references: [id])
  targets    BenchmarkTarget[]
  runs       PredictionRun[]
  statistics ModelRunStatistics[]

  @@index([series, isListed, name]) // new index for fast filtering
}

model BenchmarkTarget {
  id             String @id @default(cuid())
  benchmarkSetId String
  targetId       String // The external ID, e.g. "n5-00123"
  moleculeId     String // The SMILES/InchiKey link

  // Metadata for stratification (cached from Python model)
  // These are computed from the PRIMARY acceptable route (index 0) if available
  routeLength  Int? // Length of primary acceptable route
  isConvergent Boolean? // Is primary acceptable route convergent?
  metadata     String? // JSON blob for other metadata

  // Relations
  benchmarkSet     BenchmarkSet      @relation(fields: [benchmarkSetId], references: [id])
  molecule         Molecule          @relation(fields: [moleculeId], references: [id])
  acceptableRoutes AcceptableRoute[]
  predictionRoutes PredictionRoute[]

  @@unique([benchmarkSetId, targetId])
}

// Junction table: Links BenchmarkTarget to multiple Route records (acceptable routes)
// Preserves array order from Python model via routeIndex (0 = primary route)
model AcceptableRoute {
  id                String @id @default(cuid())
  benchmarkTargetId String
  routeId           String
  routeIndex        Int // 0-based index in acceptable_routes array (0 = primary)

  target BenchmarkTarget @relation(fields: [benchmarkTargetId], references: [id], onDelete: Cascade)
  route  Route           @relation(fields: [routeId], references: [id], onDelete: Cascade)

  @@unique([benchmarkTargetId, routeId]) // One link per target-route pair
  @@unique([benchmarkTargetId, routeIndex]) // Index is unique per target
  @@index([benchmarkTargetId])
  @@index([routeId])
}

// =================================================================================
// 3. MODELS & EXECUTION (The "Prediction" Layer)
// Matches data/3-processed/
// =================================================================================

model Algorithm {
  id          String  @id @default(cuid())
  name        String  @unique // "DirectMultiStep"
  slug        String  @unique // "direct-multi-step" (for clean urls)
  description String? // high-level explanation of the method
  paper       String? // link to paper
  codeUrl     String? // link to canonical implementation
  bibtex      String? // bibtex citation string

  instances     ModelInstance[]
  modelFamilies ModelFamily[]
}

model ModelFamily {
  id          String  @id @default(cuid())
  algorithmId String
  name        String  @unique // "SynPlanner MCTS Rollout"
  slug        String  @unique // "synplanner-mcts-rollout"
  description String?

  algorithm Algorithm       @relation(fields: [algorithmId], references: [id])
  instances ModelInstance[]

  @@index([algorithmId])
}

model ModelInstance {
  id            String  @id @default(cuid())
  algorithmId   String
  modelFamilyId String?
  name          String // "dms-explorer-xl", NOT unique anymore
  slug          String  @unique // "dms-explorer-xl-v1-2-0"
  description   String? // what makes THIS version special? "trained on new internal dataset"

  // Structured SemVer
  versionMajor      Int     @default(0)
  versionMinor      Int     @default(0)
  versionPatch      Int     @default(0)
  versionPrerelease String? // e.g., "alpha", "beta.1"

  metadata  String? // JSON: training set info, hyperparams
  createdAt DateTime @default(now())

  algorithm Algorithm       @relation(fields: [algorithmId], references: [id])
  family    ModelFamily?    @relation(fields: [modelFamilyId], references: [id])
  runs      PredictionRun[]

  // @@unique([modelFamilyId, versionMajor, versionMinor, versionPatch, versionPrerelease])
  @@unique([name, versionMajor, versionMinor, versionPatch, versionPrerelease])
  @@index([modelFamilyId])
}

enum SubmissionType {
  MAINTAINER_VERIFIED // run by us, hardware verified
  COMMUNITY_SUBMITTED // submitted by author, computationally verified
}

// Represents one "folder" in your data/3-processed structure
// e.g., data/3-processed/mkt-lin-500/dms-explorer-xl
model PredictionRun {
  id              String @id @default(cuid())
  modelInstanceId String
  benchmarkSetId  String

  // Provenance from Manifest
  retrocastVersion String?
  commandParams    String? // JSON of args
  executedAt       DateTime @default(now())

  // Cost tracking
  hourlyCost Float? // USD per hour (user-specified)
  totalCost  Float? // Pre-calculated: hourlyCost * (totalWallTime / 3600)

  // Stats from RunStatistics
  totalRoutes    Int // final_unique_routes_saved (now counts PredictionRoutes)
  avgRouteLength Float? // Average route length across all routes

  submissionType SubmissionType @default(COMMUNITY_SUBMITTED)
  isRetrained    Boolean? // for ref-* series. NULL = N/A, true/false for ref runs.

  modelInstance    ModelInstance        @relation(fields: [modelInstanceId], references: [id])
  benchmarkSet     BenchmarkSet         @relation(fields: [benchmarkSetId], references: [id])
  predictionRoutes PredictionRoute[]
  statistics       ModelRunStatistics[]

  @@unique([modelInstanceId, benchmarkSetId]) // Assuming one run per version per set
}

model Route {
  id String @id @default(cuid())

  // Core Route Properties (Topology-level, unique)
  signature   String @unique // SHA256 from get_signature() (topology only) - NOW REQUIRED & UNIQUE
  contentHash String @unique // SHA256 from get_content_hash() - NOW UNIQUE

  // Cached Computations (for fast filtering)
  length       Int
  isConvergent Boolean

  // Relations
  asAcceptableRouteFor AcceptableRoute[]
  nodes                RouteNode[]
  predictions          PredictionRoute[] // One route can be predicted multiple times
}

// Junction table: Connects a Route to a (PredictionRun, Target, Rank)
// This represents one "prediction" of a route by a model
model PredictionRoute {
  id              String @id @default(cuid())
  routeId         String // The unique route structure
  predictionRunId String // The model run that predicted this
  targetId        String // The target this prediction is for
  rank            Int // 1-indexed rank within this target/run

  metadata String? // JSON: scores, confidence, etc. (prediction-specific)

  // Relations
  route             Route              @relation(fields: [routeId], references: [id], onDelete: Cascade)
  predictionRun     PredictionRun      @relation(fields: [predictionRunId], references: [id], onDelete: Cascade)
  target            BenchmarkTarget    @relation(fields: [targetId], references: [id], onDelete: Cascade)
  solvabilityStatus RouteSolvability[]

  // Constraints
  @@unique([predictionRunId, targetId, rank]) // Each rank is unique per target/run
  @@unique([routeId, predictionRunId, targetId]) // Prevents duplicate route structures per target/run (intentional)
  @@index([targetId, rank])
  @@index([predictionRunId])
  @@index([routeId])
}

model RouteNode {
  id         String  @id @default(cuid())
  routeId    String
  moleculeId String
  parentId   String? // Tree structure

  // Reaction Step Data (The "Edge" info)
  // If this node is a product, how was it made?
  isLeaf       Boolean @default(false)
  reactionHash String? // For checking reaction overlap
  template     String?
  metadata     String? // JSON: reagents, solvents, mapper output

  // Relations
  route    Route       @relation(fields: [routeId], references: [id], onDelete: Cascade)
  molecule Molecule    @relation(fields: [moleculeId], references: [id])
  parent   RouteNode?  @relation("ReactionTree", fields: [parentId], references: [id], onDelete: SetNull, onUpdate: NoAction)
  children RouteNode[] @relation("ReactionTree")

  @@index([routeId])
}

// =================================================================================
// 4. STATISTICS & METRICS (Pre-computed results from Python pipeline)
// Matches data/5-results/ and Python ModelStatistics Pydantic model
// =================================================================================

enum ReliabilityCode {
  OK // Reliable estimate
  LOW_N // Sample size too small (n < threshold)
  EXTREME_P // Probability near boundary (p very close to 0 or 1)
}

enum VendorSource {
  MC // Mcule
  LN // LabNetwork
  EM // eMolecules
  SA // Sigma Aldrich
  CB // ChemBridge
}

model ModelRunStatistics {
  id              String   @id @default(cuid())
  predictionRunId String
  benchmarkSetId  String
  stockId         String
  statisticsJson  String // Full ModelStatistics JSON blob for flexibility
  computedAt      DateTime @default(now())

  // Runtime metrics (in seconds) from Python ModelStatistics
  totalWallTime Float? // total_wall_time from Python
  totalCpuTime  Float? // total_cpu_time from Python
  meanWallTime  Float? // mean_wall_time from Python
  meanCpuTime   Float? // mean_cpu_time from Python

  // Relations
  predictionRun PredictionRun           @relation(fields: [predictionRunId], references: [id])
  benchmarkSet  BenchmarkSet            @relation(fields: [benchmarkSetId], references: [id])
  stock         Stock                   @relation(fields: [stockId], references: [id])
  metrics       StratifiedMetricGroup[]

  @@unique([predictionRunId, stockId]) // Multiple stocks per run
  @@index([predictionRunId])
  @@index([stockId])
}

model StratifiedMetricGroup {
  id           String @id @default(cuid())
  statisticsId String

  // Metric identification
  metricName String // "Solvability", "Top-1", "Top-5", "Top-10", etc.
  groupKey   Int? // NULL for overall, route_length (2,3,4,5,6...) for stratified

  // Metric values (stored as 0-1, convert to percentage in UI)
  value    Float
  ciLower  Float
  ciUpper  Float
  nSamples Int

  // Reliability assessment
  reliabilityCode    ReliabilityCode
  reliabilityMessage String

  // Relations
  statistics ModelRunStatistics @relation(fields: [statisticsId], references: [id], onDelete: Cascade)

  @@index([statisticsId, metricName]) // Fast filtering by metric
  @@index([metricName, groupKey]) // Fast stratified queries
}

// =================================================================================
// 5. SCORING & EVALUATION (The "Stock" Layer)
// Matches retrocast.models.evaluation and data/4-scored/
// =================================================================================

model Stock {
  id          String  @id @default(cuid(2))
  name        String  @unique // "buyables-stock" (matches directory name)
  description String?

  benchmarks  BenchmarkSet[]
  items       StockItem[]
  evaluations RouteSolvability[]
  statistics  ModelRunStatistics[]
}

model StockItem {
  id         String @id @default(cuid(2))
  stockId    String
  moleculeId String

  // Commercial metadata (from buyables-meta.json.gz)
  ppg      Float? // Price per gram in USD
  source   VendorSource? // Vendor source
  leadTime String? // Lead time for delivery (e.g., '7-21days', '1week')
  link     String? // URL to vendor product page

  stock    Stock    @relation(fields: [stockId], references: [id])
  molecule Molecule @relation(fields: [moleculeId], references: [id])

  @@unique([stockId, moleculeId])
  @@index([stockId, source, ppg]) // covers vendor + price filtering
  @@index([stockId, ppg]) // covers price-only filtering
  @@index([stockId, moleculeId]) // optimize the join
}

// The result of `TargetEvaluation`
// effectively "ScoredRoute" but normalized
// NOTE: Solvability is per-PREDICTION, not per-route (same route can have different solvability in different contexts)
model RouteSolvability {
  id                String @id @default(cuid())
  predictionRouteId String // Changed from routeId - solvability is per prediction
  stockId           String

  isSolvable             Boolean
  matchesAcceptable      Boolean // "Does this route match ANY acceptable route?"
  matchedAcceptableIndex Int? // Which acceptable route was matched (0-based index, null if no match)

  // Stratification properties from Python TargetEvaluation
  // Source priority: matched acceptable route > first solved predicted route > None
  stratificationLength       Int? // stratification_length from Python
  stratificationIsConvergent Boolean? // stratification_is_convergent from Python

  // Runtime metrics for this evaluation (in seconds)
  wallTime Float? // wall_time from Python TargetEvaluation
  cpuTime  Float? // cpu_time from Python TargetEvaluation

  predictionRoute PredictionRoute @relation(fields: [predictionRouteId], references: [id], onDelete: Cascade)
  stock           Stock           @relation(fields: [stockId], references: [id])

  @@unique([predictionRouteId, stockId])
}
